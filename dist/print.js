// Generated by LiveScript 1.6.0
(function(){
  var reg, com, print, l, z, lit, c, readJson, R, showStack, metadata, show_name, print_wrap, I, key, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  reg = require("./registry");
  com = reg.com, print = reg.print;
  l = com.l, z = com.z, lit = com.lit;
  c = com.c, readJson = com.readJson, R = com.R, z = com.z, showStack = com.showStack;
  R.tryCatch(function(filename){
    var raw, pj;
    raw = readJson(filename);
    pj = {};
    pj.name = raw.name;
    pj.repourl = raw.repository;
    pj.homepage = raw.homepage;
    pj.version = raw.version;
    reg.metadata = pj;
  }, function(){
    l(c.er("- | unable to locate or parse package.json of module."));
    showStack();
  })(
  __dirname + "/../package.json");
  metadata = reg.metadata;
  show_name = function(filename){
    lit(["[" + metadata.name + "]", "[dataError]\n"], [c.er2, c.er3]);
    return l(" " + c.er1(filename) + "\n");
  };
  print.unableToReadConfigYaml = function(filename){
    lit(["[" + metadata.name + "]", "[parseError]"], [c.warn, c.er1]);
    l("\n  " + c.er2(filename));
    return l(c.grey("\n", "  make sure :\n\n", "   - correct path is provided.\n", "   - .yaml file can be parsed without error.\n", "   - .yaml file has no duplicate field."));
  };
  print.dataError = function(msg, path, filename, type){
    var init, last, intro, itype, text;
    show_name(filename);
    l(c.grey("  invalid type at :\n"));
    init = R.init(path);
    last = R.last(path);
    lit(["  ", init.join("."), "." + last, " <-- error here"], [0, c.er1, c.er3, c.er1]);
    intro = (function(){
      switch (type) {
      case 'data':
        return "\n  value is ";
      default:
        return "\n  ";
      }
    }());
    itype = msg[0], text = msg[1];
    switch (itype) {
    case 'not-valid':
      lit([intro].concat(arrayFrom$(text), ["\n"]), [0, c.warn, c.er2]);
      break;
    default:
      l(c.er1("\n  " + msg + "\n"));
    }
    return l(c.grey("  please refer to docs to provide valid values."));
  };
  print.flag = function(msg, path, filename){
    var init, last;
    show_name(filename);
    l(c.grey("  invalid type at :\n"));
    init = R.init(path);
    last = R.last(path);
    lit(["  ", init.join("."), "." + last, " <-- error here"], [0, c.er1, c.er3, c.er1]);
    l(c.er2("\n  value is " + msg + "\n"));
    return l(c.grey("  please refer to docs to provide valid values."));
  };
  print.incorrect_arg_num = function(){
    lit(["[" + metadata.name + "]", "[inputError]\n"], [c.er2, c.er3]);
    return lit(["  ", "incorrect number of arguments for function."], [0, c.er1, c.er3, c.er1]);
  };
  print.unableToParsePackageJson = function(){};
  print.req = function(props, path, filename){
    var ref$, init, last;
    show_name(filename);
    ref$ = R.splitAt(-1, path), init = ref$[0], last = ref$[1];
    lit([" required value not present in: ", "\n\n ", init.join("."), "." + last.join("."), " <-- error here", "\n"], [c.grey, 0, c.warn, c.er3, c.er2]);
    l(c.grey(" all required value(s) in object:\n"));
    return l(c.er1(" ." + props.join(" .")));
  };
  print_wrap = function(f){
    return function(){
      f.apply(null, arguments);
      l(c.grey("\n[docs] " + metadata.homepage));
      return showStack();
    };
  };
  for (I in print) {
    key = print[I];
    print[I] = print_wrap(key);
  }
}).call(this);
