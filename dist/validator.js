// Generated by LiveScript 1.6.0
(function(){
  var reg, com, print, data, metadata, l, z, j, R, readJson, readYaml, be, optionator, lit, c, maybe, log, ME, rm, util, ETYPE, rmEmptyStr, unu, rmAllUndef, merge, entry;
  reg = require("./registry");
  require("./print");
  require("./data");
  com = reg.com, print = reg.print, data = reg.data, metadata = reg.metadata;
  l = com.l, z = com.z, j = com.j, R = com.R;
  readJson = com.readJson, readYaml = com.readYaml, be = com.be, j = com.j, optionator = com.optionator, lit = com.lit, c = com.c;
  maybe = be.maybe;
  log = function(x){
    l(x);
    return x;
  };
  ME = {};
  rm = {};
  util = {};
  ME.has = function(props){
    return function(ob){
      var i$, ref$, len$, key;
      for (i$ = 0, len$ = (ref$ = props).length; i$ < len$; ++i$) {
        key = ref$[i$];
        if (ob.hasOwnProperty(key)) {
          return true;
        }
      }
      return false;
    };
  };
  ME.has_file_filter = ME.has(data.flag.filter);
  ETYPE = function(name){
    return function(msg){
      return [name, msg];
    };
  };
  rmEmptyStr = R.filter(function(x){
    if (x.length === 0) {
      return false;
    } else {
      return true;
    }
  });
  util.str2arr = function(x){
    return [x];
  };
  ME.strlistE = function(msg){
    var type1, txt, type2;
    msg = R.flatten(msg);
    type1 = msg[0], txt = msg[1], type2 = msg[2];
    switch (type1) {
    case 'list':
      return ['list', txt];
    default:
      switch (type2) {
      case 'merge':
        return ['merge'];
      default:
        return ['prime', "not a Array of string or just string."];
      }
    }
  };
  ME.recursiveStrList = be.arr.map(be.arr.and(function(arr){
    var ret;
    ret = ME.recursiveStrList.auth(arr);
    if (ret['continue']) {
      return true;
    }
    return [false, ret.message, ret.path];
  }).or(be.str).or(be.obj.jam('merge'))).alt(be.str.cont(util.str2arr)).cont(R.flatten);
  ME.strlist = function(F){
    return ME.recursiveStrList.or(be.undefnull.cont(F)).err(ME.strlistE);
  };
  ME.strlist.empty = ME.strlist(function(){
    return [];
  });
  ME.strlist.dot = ME.strlist(function(){
    return ["."];
  });
  ME.strlist.undef = ME.strlist(undefined);
  unu = be.undefnull.cont(undefined);
  util.catprime = function(arg$){
    var msg;
    msg = arg$[0];
    return ["prime", msg];
  };
  rm.secondmsg = function(F){
    return F.err(util.catprime);
  };
  ME.maybe = {};
  ME.maybe.bool = be.bool.or(unu);
  ME.maybe.num = be.num.or(unu);
  ME.maybe.str = be.str.or(unu);
  ME.maybe.obj = be.obj.or(unu);
  ME.maybe.arr = be.arr.or(unu);
  rmAllUndef = function(obj){
    return JSON.parse(JSON.stringify(obj));
  };
  merge = R.mergeDeepWith(function(A, B){
    return B;
  });
  ME.flag = {};
  ME.flag.object = be.obj.and(function(ob){
    var keys, k;
    keys = Object.keys(ob);
    if (!(keys.length === 1)) {
      return [false, ['flag', ['not-single', "object can only have singular attribute."]]];
    }
    k = keys[0];
    if (!data.flag.objectProps.has(k)) {
      return [false, ['flag', ['not-valid', ["." + k, " not a valid compound rsync option."]]]];
    }
    return true;
  }).cont(function(ob){
    var ref$, key, val;
    if ((ref$ = (function(){
      var ref$, results$ = [];
      for (key in ref$ = ob) {
        val = ref$[key];
        results$.push(val);
      }
      return results$;
    }())[0]) === undefined || ref$ === null) {
      return undefined;
    } else {
      return ob;
    }
  });
  ME.flag.string = be.maybe.str.err(['data', "not string or singular object"]).and(function(str){
    if (!data.flag.bool.has(str)) {
      return [false, ['flag', ['not-valid', [str + "", " not a valid boolean rsync option."]]]];
    }
    return true;
  });
  ME.chokidar = ME.maybe.obj.on(data.chokidar.bools, ME.maybe.bool).on(['ignored', 'cwd'], ME.maybe.str).on('awaitWriteFinish', ME.maybe.obj.on(['stabilityThreshold', 'pollInterval'], ME.maybe.num).or(be.bool)).on(['interval', 'binaryInterval', 'depth'], ME.maybe.num);
  ME.flag.main = be.arr.map(ME.flag.string.or(ME.flag.object.cont(function(ob){
    var key, I;
    key = Object.keys(ob)[0];
    if (key === 'exclude' || key === 'include' || key === 'exclude-from' || key === 'include-from') {
      return (function(){
        var i$, ref$, len$, ref1$, results$ = [];
        for (i$ = 0, len$ = (ref$ = ob[key + ""]).length; i$ < len$; ++i$) {
          I = ref$[i$];
          results$.push((ref1$ = {}, ref1$[key + ""] = I, ref1$));
        }
        return results$;
      }());
    }
    return ob;
  })).or(be.arr.and(function(arr){
    var ret;
    ret = ME.flag.main.auth(arr);
    if (ret['continue']) {
      return true;
    }
    return [false, ret.message, ret.path];
  }))).cont(R.flatten);
  ME.rsync = ME.maybe.obj.on('des', ME.strlist.undef).on('src', ME.maybe.str).on('flags', ME.flag.main);
  ME.user = be.obj.or(be.undefnull.cont(function(){
    return {};
  })).and(be.restricted(['watch', 'localbuild', 'remotetask', 'remotehost', 'chokidar', 'rsync', 'initialize'])).on('initialize', ME.maybe.bool).on('watch', ME.strlist.undef).on('remotetask', ME.strlist.undef).on('localbuild', ME.strlist.undef).on('chokidar', ME.chokidar).on('rsync', ME.rsync.or(unu));
  ME.main = be.required(['remotehost', 'remotefold']).on('initialize', be.bool.or(be.undefnull.cont(true))).on('watch', ME.strlist.dot).on('localbuild', ME.strlist.empty).on('remotetask', ME.strlist.empty).on('chokidar', ME.chokidar).on('rsync', be.obj.alt(be.undefnull.cont(function(){
    return {};
  })).on('src', be.str.or(be.undefnull.cont("."))).on('des', ME.strlist(function(){
    return [arguments[3].origin.remotefold];
  })).and(ME.rsync.or(be.undefnull.cont([])))).and(function(data, state){
    var i$, ref$, len$, I;
    for (i$ = 0, len$ = (ref$ = state.cmd).length; i$ < len$; ++i$) {
      I = ref$[i$];
      if (!data[I]) {
        return [false, ['usercmd_not_defined', I]];
      }
    }
    return true;
  }).map(function(value, key, state){
    var fin, put;
    fin = state.fin;
    switch (data.selected_keys.set.has(key)) {
    case true:
      fin.def[key] = value;
      break;
    case false:
      put = ME.user.auth(value, key, state);
      if (put['continue']) {
        fin.user[key] = put.value;
      } else {
        return [false, ['usercmd', put.message], put.path];
      }
    }
    state.fin = rmAllUndef(fin);
    return true;
  }).err(function(msg, path, arg$){
    var filename;
    filename = arg$.filename;
    return z(msg, path);
  }).cont(function(__, arg$){
    var fin, user, def, nuser, key, value;
    fin = arg$.fin;
    user = fin.user, def = fin.def;
    nuser = {};
    for (key in user) {
      value = user[key];
      nuser[key] = merge(def, value);
    }
    fin.user = nuser;
    return fin;
  }).cont(reg.core);
  entry = function(data){
    var FILENAME, raw, Er, state, ref$;
    FILENAME = process.cwd() + "/" + data.filename;
    try {
      raw = readYaml(FILENAME);
    } catch (e$) {
      Er = e$;
      if (data.verbose) {
        l(Er);
      }
      print.unableToReadConfigYaml(data.filename);
    }
    state = {
      filename: data.filename,
      origin: raw,
      cmd: data.cmd,
      fin: (ref$ = {}, import$(ref$, data), ref$.def = {}, ref$.user = {}, ref$)
    };
    return ME.main.auth(raw, state);
  };
  reg.validator = entry;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
