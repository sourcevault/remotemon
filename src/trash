reg = require "./registry"

require "./print"      #  [...load print.js...]

require "./data"       #  [...load data.js...]

require "./core"       #  [...load core.js...]

require "./validator"  #  [...load validator.js...]

{com,print,metadata} = reg

#---------------------------------------------------

{l,z,j,R,fs,lit,c} = com

{read-json,read-yaml,be,j,optionator,hop,exec,be,show-stack} = com

#--------------------------------------------------

l lit do
  ["#{metadata.name} does not proide progrmmable API for now :("]
  [c.er1]

# auth = (V)-> ->

#   torn = V.auth arguments

#   if (torn.error)

#     if (torn.path.length > 0)

#       [false,[torn.message,torn.path]]

#     else

#       false

#   [true,torn.value]

# strlist = be.arr.map be.str
# .or be.str.cont (str)-> [str]

# validate2str = be.arg
# .on 0,be.str
# .on 1,strlist
# .cont ([filename,cmd]) ->

#   filename = reg.validator.findfile filename

#   switch filename
#   | false     => false
#   | otherwise =>
#     *cmd      : cmd
#      filename : filename
#      verbose  : false
#      dryRun   : false


# validate_opt = be
# .restricted [\verbose,\dryRun]
# .on [\verbose,\dryRun],be.bool


# validate2obj = be.arg
# .on 0,be.obj
# .on 1,validate_opt
# .cont ([raw_object,opts]) !->


#   z "hello world"


#   # state =
#   #   filename : void
#   #   origin   : raw_object
#   #   cmd      : []
#   #   verbose  : opts.verbose
#   #   dryRun   : opts.dryRun
#   #   def      : {}
#   #   user     : {}

#   # reg.validator.only_object.auth raw_object,state


# # validate3 = be.arg
# # .on 0,be.str
# # .on 1,strlist



# main = hop

# .arn [1,2,3],
#   print.incorrect_arg_num

# # .ar 1,
# #   (config_raw) ->

# #     state =
# #       filename : void
# #       origin   : config_raw
# #       cmd      : []
# #       verbose  : false
# #       dryRun   : false
# #       def      : {}
# #       user     : {}

# #     reg.validator.only_object.auth config_raw,state


# # .ar 2,
# #   auth validate2str
# #   reg.validator

# # .arma 2,
# #   auth validate2obj
# #   ->

# # .arma 3,
# #   auth validate3
# #   reg.validator

# .def print.no_match_for_arguments

# entry = hop
# .wh do

#   -> if not (metadata.name) then false else true
#   -> main arguments

# .def !->

#   lit do
#     ["[remotemon]"," unable to locate or parse package.json of module."]
#     [c.er3,c.er1]



# module.exports = entry